{
  "document": {
    "document_id": "patchboard-atlas.spec",
    "version": "0.1",
    "type": "master-spec",
    "purpose": "Defines the Patchboard Atlas tool: its intent, scope, design principles, internal data models, and interaction grammar. This document is the authoritative root specification for the Patchboard Atlas project.",
    "status": "draft",
    "depends_on": [
      "tkintertester.spec.v0.1",
      "lionscliapp.initial-spec.v0_3",
      "patchboard.spec.messages.core.v1",
      "patchboard.spec.messages.file-transport.v1"
    ],
    "notes": "This specification intentionally separates project definition from runtime state and operational data. Patchboard Atlas observes and influences Patchboard Routers exclusively via FileTalk message exchange and published state artifacts."
  },
  "links": {
    "github": "https://github.com/LionKimbro/patchboard-atlas",
    "conversations": {
      "first-conversation": "https://chatgpt.com/g/g-p-6965e8dcf0388191b49d2611e683eef8-filetalk-epoch-5-core-spec/c/69817e93-df78-8331-846e-2d95e7dfab7f"
    },
    "support-documentation": {
      "patchboard.spec.messages.core.v1": {
        "document_id": "patchboard.spec.messages.core.v1",
        "filepath": "F:/lion/github/filetalk/docs/spec/patchboard-core.v1.json",
        "title": "Patchboard Core Message Specification",
        "purpose": "This describes how the Patchboard system works, and how messages are defined in it."
      },
      "patchboard.spec.messages.file-transport.v1": {
        "document_id": "patchboard.spec.messages.file-transport.v1",
        "filepath": "F:/lion/github/filetalk/docs/spec/patchboard-file-transport.v1.json",
        "title": "Patchboard File Transport Profile",
        "purpose": "This describes how files and folders are used in the Patchboard system, to communicate messages."
      },
      "lionscliapp.api.v1": {
        "document_id": "lionscliapp.api.v1",
        "filepath": "f:/lion/github/lionscliapp/doc/lionscliapp_api.json",
        "title": "Lion's CLI App (lionscliapp) API Documentation",
        "purpose": "Patchboard Atlas will be invoked via the lionscliapp module, this is the documentation for it."
      },
      "tkintertester.spec.v0.1": {
        "document_id": "tkintertester.spec.v0.1",
        "filepath": "F:/lion/github/tkintertester/tkintertester_spec.json",
        "title": "tkintertester Specification",
        "purpose": "I want to be able to run tests with tkinter, and that requires some special handling.  This is the specification (and some examples) for how to use tkintester to do so.  It does require some specific structuring of the program, though, so be alert here."
      },
      "lionsphilosophyofprogramming.2025.simplified": {
        "document_id": "lionsphilosophyofprogramming.2025.simplified",
        "filepath": "F:/lion/github/lions-documents/coding-guidelines/v2026-01-14_part2_lions-philosophy-of-programming_simplified.json",
        "title": "Lion's Python Programming Guidelines (2025) -- Simplified Edition",
        "purpose": "These are my general Python programming guidelines, in a simplified form."
      },
      "spec.filetalk-patchboard-router": {
        "document_id": "spec.filetalk-patchboard-router",
        "filepath": "f:/lion/github/filetalk/docs/spec/patchboard-router.v0.1.json",
        "title": "Patchboard Router All-Aspects Design Document",
        "purpose": "Ultimately, Patchboard Atlas is here to command the Patchboard Router.  This is the specification guide for said router, until I get around to making merely an API reference for it."
      }
    }
  },
  "content": {
    "overview": {
      "summary": "Patchboard Atlas is a graphical configuration and observation tool for FileTalk Patchboard Routers. It provides a canvas-based interface for placing components, wiring connections, and visualizing routing topology, while treating the Patchboard Router as the sole authoritative source of routing state.",
      "non_goals": [
        "Direct mutation of router internal state",
        "Defining message transport semantics",
        "Providing delivery guarantees or acknowledgements beyond those defined by Patchboard Router"
      ],
      "future-goals-but-not-now": [
        "Executing or hosting FileTalk components"
      ]
    },
    "project": {
      "name": "patchboard-atlas",
      "version": "0.1",
      "kind": "graphical-tool",
      "domain": "filetalk",
      "role": "patchboard-visual-configurator",
      "description": "A graphical editor and observer for FileTalk Patchboard Routers, implemented in Python using Tkinter and Canvas."
    },
    "design_principles": [
      "Observer-first architecture: the router is always authoritative",
      "All routing mutations are requested indirectly via FileTalk messages",
      "Patchboard Atlas never assumes immediate success of user actions",
      "Canvas rendering is driven exclusively by a pure data model",
      "Eventual convergence is preferred over synchronous confirmation",
      "Underspecified interaction is acceptable; architectural clarity is not"
    ],
    "architectural-role": {
      "atlas": {
        "role": "observer-and-requestor",
        "responsibilities": [
          "Render a visual model of components and routes",
          "Emit link and unlink requests via FileTalk messages",
          "Observe router change notices and re-read published state",
          "Reconcile visual intent with authoritative router state"
        ],
        "explicit_non_responsibilities": [
          "Maintaining authoritative routing tables",
          "Guaranteeing delivery or ordering semantics",
          "Performing component execution or scheduling"
        ]
      },
      "router": {
        "role": "authoritative-routing-engine",
        "relationship": "Patchboard Atlas treats all router-published state as authoritative and opaque."
      }
    },
    "component-id-card-schema": {
      "schema_version": "1",
      "purpose": "Defines the declarative structure of a single live Component ID Card describing an already-running FileTalk component. These cards are instance representations, not type definitions.",
      "description": "A Component ID Card is a self-description emitted or provided by a running FileTalk component. Patchboard Atlas consumes these cards to render and wire live components.",
      "record-format": {
        "schema_version": "int -- must equal 1",
        "title": "str -- human-readable name for the running component",
        "channels": {
          "in": "list[str] -- channel names accepted by this component",
          "out": "list[str] -- channel names emitted by this component"
        },
        "inbox": "str -- canonical absolute path to this component's INBOX folder",
        "outbox": "str -- canonical absolute path to this component's OUTBOX folder"
      },
      "invariants": [
        "inbox and outbox must be canonical absolute paths.",
        "Channel names must be unique within their respective 'in' and 'out' arrays.",
        "The ID card represents a single running component instance."
      ],
      "notes": "Component ID Cards describe connectable affordances and runtime folder bindings for live processes. They do not define component types, execution behavior, or routing state. Routing topology remains authoritative in patchboard-router routes.json."
    },
    "built-in-components": {
      "schema_version": "1",
      "purpose": "Defines component types built into Patchboard Atlas for initial operation and testing.",
      "components": [
        {
          "component_type": "patchboard.router",
          "title": "Patchboard Router",
          "channels": {
            "in": [
              "link",
              "unlink",
              "quit"
            ],
            "out": [
              "notice",
              "startup",
              "shutdown"
            ]
          }
        }
      ]
    },
    "atlas-world-model-schema": {
      "schema_version": "1",
      "purpose": "Defines the internal world model rendered by the Atlas canvas and manipulated by user interaction.",
      "entities": {
        "component_instance": {
          "fields": [
            "instance_id",
            "component_type",
            "position"
          ],
          "notes": "Component instances represent visual placements, not authoritative runtime entities."
        },
        "wire": {
          "fields": [
            "from",
            "to",
            "status"
          ],
          "notes": "Wire status may include transient or pending states reflecting reconciliation with router state."
        }
      }
    },
    "internal-data": {
      "description": "Defines the concrete in-memory data structures used during execution. These structures are implemented as module-level dictionaries and scalars. This is not a persistence format.",
      "naming-conventions": {
        "g_": "Scalar global values.",
        "cmp_": "ECS component maps keyed by ECS ID.",
        "idx_": "Maintained indices derived from ECS or external data.",
        "loaded_": "Externally sourced cached data."
      },
      "log": {
        "defined-in": {
          "module": "log.py",
          "name": "g_log"
        },
        "type": "list[log_record]",
        "description": "Append-only structured log buffer for runtime and startup validation events. Rendered by the Console window when opened.",
        "record-format": {
          "timestamp": "str (UTC ISO8601)",
          "level": "str (info | warning | error)",
          "category": "str",
          "message": "str",
          "context": "dict[str -> any]"
        }
      },
      "globals": {
        "g['next_entity_id']": {
          "defined-in": {
            "module": "ecs_world.py",
            "name": "g_next_entity_id"
          },
          "type": "int",
          "description": "Monotonically increasing positive integer used to assign new ECS IDs."
        }
      },
      "ecs-state": {
        "cmp_entities": {
          "defined-in": {
            "module": "ecs_world.py",
            "name": "cmp_entities"
          },
          "type": "set[int]",
          "description": "Set of active ECS IDs representing all known entities in the Atlas identity layer. Component instances are one class of entity; future entity types may exist without cmp_card_ref. Each ECS ID present in cmp_card_ref must also be present in this set."
        },
        "cmp_spatial": {
          "defined-in": {
            "module": "ecs_world.py",
            "name": "cmp_spatial"
          },
          "type": "dict[int -> spatial_record]",
          "description": "World-space placement of entities.",
          "record-format": {
            "x": "int -- top-left X position in world pixels",
            "y": "int -- top-left Y position in world pixels",
            "width": "int -- width in world pixels",
            "height": "int -- height in world pixels"
          },
          "notes": "World coordinates are integer pixel units before camera transform.\nPresence in cmp_spatial indicates spatial placement on the canvas. Entities without cmp_spatial entries exist but are not visually placed."
        },
        "cmp_card_ref": {
          "defined-in": {
            "module": "ecs_world.py",
            "name": "cmp_card_ref"
          },
          "type": "dict[int -> component_id_card]",
          "description": "Maps ECS IDs to their associated Component ID Card objects. Each entry represents a known component instance in the ECS identity layer, regardless of spatial placement. The referenced Component ID Card supplies title, channels, inbox, and outbox data. The component_id_card value must be one of the objects contained in loaded_component_id_cards; no duplication of card data is permitted within the ECS. If the referenced Component ID Card is invalidated during startup validation, the ECS entity must be removed immediately."
        }
      },
      "reverse-indices": {
        "idx_folder_to_entity": {
          "defined-in": {
            "module": "router_projection.py",
            "name": "idx_folder_to_entity"
          },
          "type": "dict[str -> int]",
          "description": "Maps canonical folder paths to ECS IDs.",
          "notes": "Derived from component configuration; not part of ECS.  Rebuilt whenever cmp_entities or cmp_card_ref changes."
        }
      },
      "external-caches": {
        "loaded_router_routes": {
          "defined-in": {
            "module": "router_projection.py",
            "name": "loaded_router_routes"
          },
          "type": "list[route_record]",
          "description": "Cached contents of Patchboard Router routes.json.",
          "record-format": {
            "source-folder": "str (canonical absolute path)",
            "source-channel": "str",
            "destination-folder": "str (canonical absolute path)",
            "destination-channel": "str"
          },
          "notes": "Authoritative schema defined in patchboard.spec.messages.core.v1 and file-transport.v1. Re-read fully on router notice. Atlas does not diff incrementally; the cache is replaced wholesale."
        },
        "loaded_component_id_cards": {
          "defined-in": {
            "module": "component_registry.py",
            "name": "loaded_component_id_cards"
          },
          "type": "dict[str -> component_id_card]",
          "key": "str -- canonical absolute inbox path used as primary key",
          "description": "Disk-backed cache of imported Component ID Cards. Serves as the persistence layer and startup source for creating ECS entities. Cards may exist even if the corresponding component process is not currently running.",
          "record-format": {
            "schema_version": "int",
            "title": "str",
            "channels": {
              "in": "list[str]",
              "out": "list[str]"
            },
            "inbox": "str (canonical absolute path)",
            "outbox": "str (canonical absolute path)"
          },
          "lifecycle": [
            "Populated at startup by loading persisted JSON files.",
            "Updated when user imports new cards.",
            "If runtime validation fails (missing inbox/outbox folders), the card is deleted from disk and removed from this cache.",
            "ECS entities are created from this cache but form a separate identity layer."
          ],
          "notes": "This structure is the persistence/cache layer only. ECS identity is maintained separately in cmp_entities and cmp_card_ref."
        }
      },
      "camera": {
        "defined-in": {
          "module": "coord_machine.py",
          "name": "cam"
        },
        "type": "dict",
        "fields": {
          "x": "int -- world offset",
          "y": "int -- world offset",
          "zoom-num": "int -- zoom numerator",
          "zoom-den": "int -- zoom denominator"
        },
        "notes": "Zoom is represented as a rational number (zoom-num / zoom-den) to avoid cumulative floating-point error."
      }
    },
    "interaction-rules": {
      "purpose": "Defines the abstract interaction grammar supported by Patchboard Atlas. These actions describe user intent, not specific gestures or input devices.",
      "actions": [
        "add_component",
        "delete_component",
        "move_component",
        "begin_wire",
        "complete_wire",
        "cancel_wire"
      ],
      "notes": "Gesture mapping (mouse buttons, drag semantics, keyboard shortcuts) is explicitly out of scope for this specification."
    },
    "reconciliation-model": {
      "purpose": "Describes how Patchboard Atlas reconciles user intent with authoritative router state.",
      "principles": [
        "User actions emit requests, not state changes",
        "Router emits coarse-grained change notices",
        "Atlas responds by re-reading published router state",
        "Visual state converges toward authoritative truth"
      ],
      "notes": "Temporary visual divergence (e.g., pending wires) is considered a feature, not a failure.  A component may participate in routing topology even if it has no spatial placement (i.e. no cmp_spatial definition). Such components exist in ECS but are not rendered on the canvas."
    },
    "testing-strategy": {
      "purpose": "Defines the testing posture for Patchboard Atlas.",
      "layers": [
        {
          "name": "pure-logic-tests",
          "description": "Non-GUI tests validating data models, reconciliation logic, and invariants."
        },
        {
          "name": "event-loop-tests",
          "description": "Tkinter-based automated tests executed inside a real Tk mainloop using tkintertester."
        }
      ]
    },
    "test-expectations": {
      "invariants": [
        "component_instances_have_unique_ids",
        "wires_connect_existing_ports",
        "no_gui_action_mutates_router_state_directly",
        "visual_state_can_be_reconstructed_from_model"
      ]
    },
    "development-process": {
      "initial-goals": [
        "DONE: establish 2-part testing basis (guitest, test)",
        "DONE: salvage marginalia-atlas: coordinates drawing",
        "get the data model for components and logic and rendering in place",
        "start with being able to depict components",
        "pan and fixed-levels zoom [no text during zoom, initially]",
        "operations"
      ]
    }
  }
}
